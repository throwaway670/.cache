# -*- coding: utf-8 -*-
"""LVQ_B3_ classify loan applicants as Approved or Rejected based on financial and personal attributes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F92tbLL5TkLd-UNi-yI7aBZvUFr24HL3
"""

import numpy as np
from sklearn.preprocessing import MinMaxScaler

# -----------------------------
# 1. TRAINING DATA
# -----------------------------
X = np.array([
    [80, 750, 30, 1, 25],   # A1
    [40, 600, 50, 1, 45],   # A2
    [90, 780, 20, 1, 20],   # A3
    [35, 550, 60, 0, 50],   # A4
    [70, 720, 35, 1, 30]    # A5
], dtype=float)

y = np.array([
    [1, 0],   # Approved
    [0, 1],   # Rejected
    [1, 0],   # Approved
    [0, 1],   # Rejected
    [1, 0]    # Approved
])

ids = ["A1", "A2", "A3", "A4", "A5"]

# -----------------------------
# 2. NORMALIZATION
# -----------------------------
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)

# -----------------------------
# 3. INITIAL PROTOTYPES (1 per class)
# -----------------------------
# Choose first sample from each class as prototype
W = np.array([
    X_scaled[0],  # Prototype for Approved (class 1)
    X_scaled[1]   # Prototype for Rejected (class 2)
])

W_labels = np.array([
    [1, 0],   # Approved
    [0, 1]    # Rejected
])

learning_rate = 0.3

# -----------------------------
# 4. LVQ TRAINING FUNCTION
# -----------------------------
def lvq_train(X, y, W, W_labels, lr, epochs=10):
    for ep in range(epochs):
        for i, sample in enumerate(X):
            label = y[i]

            # Compute distances to prototypes
            distances = np.linalg.norm(W - sample, axis=1)

            # Winner prototype
            winner = np.argmin(distances)

            # If class matches → move closer
            if np.array_equal(label, W_labels[winner]):
                W[winner] += lr * (sample - W[winner])
            else:
                # If class mismatch → move away
                W[winner] -= lr * (sample - W[winner])

        lr *= 0.9   # optional decay

    return W

# -----------------------------
# 5. TRAIN LVQ
# -----------------------------
W_final = lvq_train(X_scaled, y, W.copy(), W_labels, learning_rate)

# -----------------------------
# 6. CLASSIFY TRAINING SAMPLES
# -----------------------------
def lvq_predict(sample, W, W_labels):
    distances = np.linalg.norm(W - sample, axis=1)
    winner = np.argmin(distances)
    return W_labels[winner]

print("Final LVQ Predictions:")
for i, sample in enumerate(X_scaled):
    pred = lvq_predict(sample, W_final, W_labels)
    print(ids[i], "→ Predicted:", pred)